initialize() {
	// setSeed(2073423208520);
	setSeed(rdunif(1, 0, asInteger(2^62) - 1));
	initializeSLiMModelType("nonWF");
	defineConstantIfNotExist("mutsFrequency",0.10);
	defineConstantIfNotExist("mutsCount",100);
	defineConstantIfNotExist("mutsHetFitnessDiff",0.000);
	defineConstantIfNotExist("homozygousSterilityChance",1.0);
	defineConstantIfNotExist("genomeSize",100000);
	defineConstantIfNotExist("migrantsSize",100);
	defineConstantIfNotExist("sterility",T);
	defineConstantIfNotExist("xlinked",F);
	defineConstantIfNotExist("maximalGrowthRate",1.0);
	defineConstantIfNotExist("carryingCapacity",1000);
	defineConstantIfNotExist("outputFilePath","./out1");
	defineConstantIfNotExist("recombinationRate",1e-8);
	defineGlobal("femaleReproductiveOutput", c(0.0,0.0));
	
	initializeMutationRate(0.0);
	initializeMutationType("m0", 0.5, "f", 0.0);
	initializeGenomicElementType("g0", m0, 1.0);
	initializeGenomicElement(g0, 0, genomeSize-1);
	initializeRecombinationRate(recombinationRate);
	initializeSex(xlinked ? "X" else "A");
	
	for (i in seqLen(mutsCount)+1) {
		mut = initializeMutationType("m"+asString(i) , 1.0, "f", mutsHetFitnessDiff);
		mut.color = "green"; 
//		gelement = initializeGenomicElementType("g"+asString(i), mut, 1.0);
//		initializeGenomicElement(gelement, asInteger(genomeSize/mutsCount*(i-1)), asInteger(genomeSize/mutsCount*i-1));
	}
}

function (void)defineConstantIfNotExist(string$ symbol, * value) {
	if (!exists(symbol)) {
		defineConstant(symbol,value);	
	}
}

1 early() {
	sim.addSubpop(0, carryingCapacity);
	sim.addSubpop(1, 0);
}

1 late() {
	// add mutations
	muts = community.allMutationTypes;
	possibleCarrierChromosomes = sim.subpopulations.individuals.genomes[!(sim.subpopulations.individuals.genomes.isNullGenome)];
	for (i in seqLen(mutsCount)+1) {
		sample(
			possibleCarrierChromosomes, 
			asInteger(mutsFrequency*size(possibleCarrierChromosomes))
		).addNewDrawnMutation(muts[i], asInteger(genomeSize*(i-0.5)/mutsCount));
	}
	// create founder population
	if (size(sim.subpopulations[0].individuals) > migrantsSize) {
		migrants = sample(sim.subpopulations[0].individuals, migrantsSize);
		sim.subpopulations[1].takeMigrants(migrants);
	}
	// kill core since no longer needed
	sim.killIndividuals(sim.subpopulations[0].individuals);
	
	//stats
	defineConstant("foundingMalesCount",sum(migrants.sex=="M"));
}

first() {
	//reproductive output calculations
	for (subpop in sim.subpopulations)
	{
		femaleCount = size(subpop.individuals[subpop.individuals.sex =='F']);
		if (subpop.individualCount==0 | femaleCount==0) {
			femaleReproductiveOutput[subpop.id]=0;
			next;
		}
		effectivePopulationSize = 4*femaleCount*(subpop.individualCount-femaleCount)/subpop.individualCount;
		femaleReproductiveOutput[subpop.id] = (subpop.individualCount+maximalGrowthRate*effectivePopulationSize*(1-effectivePopulationSize/carryingCapacity))/femaleCount;
		
		print(femaleCount);
		print(subpop.individualCount);
		print(effectivePopulationSize);
		print(femaleReproductiveOutput);
	}
}


reproduction(NULL, "F") {
	//steriles dont reproduce
	if (sterility)
		if (any(2<=copiesOfMutations(individual, community.allMutationTypes)))
			return;
	//produce offspring
	growthRate=max(femaleReproductiveOutput[subpop.id],-1.9999999);
	for (i in seqLen(rpois(1, growthRate))) {
		mate = subpop.sampleIndividuals(1, sex="M");	
		if (size(mate)) {
			subpop.addCrossed(individual, mate);
		}
	}
}

modifyChild() {
	//lethals die
	if (sterility)
		return T;
	if (child.sex!="F")
		return T;
	return !any(2<=copiesOfMutations(child, community.allMutationTypes));
		 
}

function (integer)copiesOfMutations(o<Individual>$ ind, o<MutationType> mutTypes) {	
	out = c();
	for (mutType in mutTypes) {
		mut = sim.mutationsOfType(mutType);
		//mutation present
		if (size(mut) != 1) {
			out = c(out,0);
			next;
		}
			
		//copies
		hasMutOnChromosome1 = ind.genome1.containsMutations(mut);
		hasMutOnChromosome2 = ind.genome2.containsMutations(mut);
		out = c(out, asInteger(hasMutOnChromosome1) + asInteger(hasMutOnChromosome2));
	}
	return out;
}

early() {
	//kill old individuals
	inds = sim.subpopulations.individuals; 
	sim.killIndividuals(inds[inds.age >= 1]);
}

1: late() {
	//end condition 1: population crash
	if (size(sim.subpopulations[1].individuals) == 0) {
		cat("EXTINCT\n");
		writeOutputData("EXTINCT");
		sim.simulationFinished();
	}
	//end condition 2: survival
	if (size(sim.subpopulations[1].individuals) >= carryingCapacity) {
		cat("SURVIVED\n");
		writeOutputData("SURVIVED");
		sim.simulationFinished();
	}
	
}

2000 late() {
	//end condition 2: long term survival
	result = size(sim.subpopulations[1].individuals) >= 0.8*carryingCapacity ? "SURVIVED" else "LOADED_SURVIVAL";
	cat(result+"\n");
	writeOutputData(result);
	sim.simulationFinished();

}

function (void)writeOutputData(string result) {
	writeFile(outputFilePath, 
		asString(getSeed())+","+ 
		asString(result)+","+
		asString(sim.cycle)+","+
		asString(mutsFrequency)+","+
		asString(mutsCount)+","+
		asString(maximalGrowthRate)+","+
		asString(recombinationRate)+","+
		asString(migrantsSize)+","+
		asString(foundingMalesCount)+","+
		asString(sterility)+","+
		asString(xlinked)
	, append = T);
}